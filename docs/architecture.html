<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="../assets/portfolio.css">
  <script src="../submenu.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism-tomorrow.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-dart.min.js"></script>

  <title>技術スタック</title>
</head>
<body>
  <header class="progress-bar">
    <h3>portfolio/architecture</h3>
    <div class="center-container">
      <div class="beige-background">
        <div class="upper-nav">
          <a href="../index.html">Home</a>
          <div class="portfolio-dropdown">
            <a href="#" id="portfolio-link" onclick="togglePortfolioFixed(event)">Portfolio</a>
            <div id="portfolio-submenu" class="portfolio-submenu">
              <a href="tech.html">技術スタック</a>
              <a href="architecture.html">アプリケーション構造</a>
              <a href="feature.html">主要機能</a>
              <a href="overview.html">今後の展望</a>
            </div>
          </div>
          <a href="profile.html">Profile</a>
        </div>
      </div>
    </div>
  </header>
  <div class="abstract">
    <h3>🏯</h3>
    <h1>アプリケーション構造</h1>
    <h2>アプリケーション構造まとめ  (2025/6 現在)</h2>
  </div>
  <div class="container">
    <main>
      <h2>アプリケーション構造（ディレクトリ構成）</h2>
      <!-- 全体構造 -->
      <h3 id="section1">unreal.app全体構造</h3>
      <p>unreal.appは標準的なFlutterプロジェクト構造をベースに、フィーチャー駆動設計（Feature-Driven Design）を採用したマルチプラットフォーム対応の構成となっています。</p>
      <h4>プロジェクトルート構造</h4>
      <div class="center-container">
        <pre><code class="language-bash">
  unreal_app/
  ├── lib/                    # メインソースコード
  ├── assets/                 # 画像・フォント・アイコンリソース
  ├── test/                   # テストファイル
  ├── android/                # Android固有の設定
  ├── ios/                    # iOS固有の設定
  ├── web/                    # Web固有の設定
  ├── windows/                # Windows固有の設定
  ├── macos/                  # macOS固有の設定
  ├── linux/                  # Linux固有の設定
  ├── supabase/               # Supabaseバックエンド設定
  ├── .cursor/                # Cursor IDE設定
  ├── pubspec.yaml            # 依存関係定義
  ├── analysis_options.yaml   # 静的解析設定
  └── README.md               # プロジェクト説明
        </code></pre>
      </div>
      <p>この構成は、クロスプラットフォーム対応・バックエンド連携・開発環境の設定管理を一貫して行えるよう設計されています。</p><hr>
      <!-- libディレクトリ構造 -->
      <h3 id="section2">libディレクトリ構造（詳細）</h3>
      <p>libディレクトリはアプリケーションのメインロジックを含み、クリーンアーキテクチャとフィーチャー駆動設計の原則に基づいて構成されています。</p>
      <h4>libディレクトリ全体構造</h4>
      <div class="center-container">
        <pre><code class="language-bash">
  lib/
  ├── main.dart               # アプリケーションエントリーポイント
  ├── core/                   # 共通コア機能
  │   ├── router.dart         # GoRouterによるルーティング設定
  │   ├── services/           # 共通サービス層
  │   │   ├── auth_service.dart       # 認証サービス
  │   │   ├── supabase_service.dart   # Supabaseクライアント管理
  │   │   └── user_service.dart       # ユーザー管理サービス
  │   └── config/             # アプリケーション設定
  │       └── env_config.dart # 環境変数設定
  ├── features/               # フィーチャー別実装
  │   ├── auth/               # 認証機能
  │   ├── common/             # 共通機能
  │   ├── lobby/              # ロビー機能
  │   ├── title/              # タイトル画面
  │   ├── group/              # グループ機能
  │   ├── werewolf/           # ワンナイト人狼ゲーム
  │   └── hanafuda/           # 花札ゲーム
  ├── utils/                  # ユーティリティ関数（現在は空）
  └── widgets/                # 共通ウィジェット（現在は空）
        </code></pre>
      </div>
      <h4>coreディレクトリの役割</h4>
      <div class="center-container">
        <pre><code class="language-dart">
  // core/router.dart - アプリケーション全体のルーティング管理
  final Provider<GoRouter> routerProvider = Provider<GoRouter>((Ref ref) {
    return GoRouter(
      initialLocation: '/',
      routes: <RouteBase>[
        GoRoute(path: '/', builder: (context, state) => const TitleScreen()),
        GoRoute(path: '/lobby', builder: (context, state) => const LobbyScreen()),
        GoRoute(path: '/game/werewolf/:roomId/:playerId',
        builder: (context, state) => WerewolfRoomScreen(...)),
      ],
    );
  });
        </code></pre>
      </div>

      <h4>featuresディレクトリの設計思想</h4>
      <p>各フィーチャーは独立したモジュールとして設計され、以下の原則に従っています：</p>
      <ul>
        <li><strong>自己完結性</strong>：各フィーチャーは独立して動作可能</li>
        <li><strong>レイヤー分離</strong>：presentation, application, domain, infrastructureに分離</li>
        <li><strong>依存関係の明確化</strong>：共通機能はcoreまたはcommonを通じて利用</li>
      </ul><hr>
      <!-- werewolfディレクトリ構造 -->
      <h3 id="section3">werewolfディレクトリ構造（詳細）</h3>
      <p>werewolfフィーチャーは、クリーンアーキテクチャの4層構造を採用した代表的な実装例となっています。</p>
      <h4>werewolfディレクトリ全体構造</h4>
      <div class="center-container">
        <pre><code class="language-bash">
  lib/features/werewolf/
  ├── presentation/           # プレゼンテーション層
  │   ├── werewolf_room_screen.dart       # ゲームルーム画面（71KB）
  │   ├── werewolf_title_screen.dart      # タイトル画面（10KB）
  │   ├── controllers/                    # UI状態管理
  │   │   └── werewolf_game_controller.dart
  │   └── providers/                      # Riverpodプロバイダー
  │       └── werewolf_room_provider.dart
  ├── application/            # アプリケーション層
  │   └── werewolf_game_service.dart      # ゲームビジネスロジック（23KB）
  ├── domain/                 # ドメイン層
  │   ├── werewolf_models.dart            # 共通モデル定義
  │   ├── werewolf_models.freezed.dart    # 自動生成ファイル
  │   ├── werewolf_models.g.dart          # JSON生成ファイル
  │   ├── entities/                       # エンティティ
  │   │   ├── werewolf_room.dart          # ゲームルームエンティティ
  │   │   ├── werewolf_player.dart        # プレイヤーエンティティ
  │   │   ├── werewolf_role.dart          # 役職エンティティ
  │   │   └── *.freezed.dart / *.g.dart   # 自動生成ファイル
  │   ├── models/                         # 値オブジェクト
  │   ├── bot/                            # ボット戦略
  │   └── repositories/                   # リポジトリインターフェース
  ├── infrastructure/         # インフラストラクチャ層
  │   └── werewolf_repository.dart        # データ永続化実装
  └── data/                   # データ層（現在は空）
        </code></pre>
      </div>

      <h4>各層の責務と実装例</h4>

      <h5>1. Presentation層（プレゼンテーション層）</h5>
      <div class="center-container">
        <pre><code class="language-dart">
  // presentation/werewolf_room_screen.dart
  class WerewolfRoomScreen extends ConsumerStatefulWidget {
    final String roomId;
    final String playerId;

    const WerewolfRoomScreen({
      super.key,
      required this.roomId,
      required this.playerId,
    });

    @override
    ConsumerState<WerewolfRoomScreen> createState() => _WerewolfRoomScreenState();
  }

  // UI状態とユーザーインタラクションを管理
  // ゲームのリアルタイム表示を担当
        </code></pre>
      </div>

      <h5>2. Application層（アプリケーション層）</h5>
      <div class="center-container">
        <pre><code class="language-dart">
  // application/werewolf_game_service.dart
  class WerewolfGameService {
    final WerewolfRepository repository;

    WerewolfGameService(this.repository);

    /// ゲーム開始処理
    Future<WerewolfRoom> startGame(WerewolfRoom room) async {
      // ビジネスロジック実装
      final updatedRoom = room.copyWith(
        phase: GamePhase.night,
        gameStartTime: DateTime.now(),
      );

      await repository.saveRoom(updatedRoom);
      return updatedRoom;
    }
  }
        </code></pre>
      </div>

      <h5>3. Domain層（ドメイン層）</h5>
      <div class="center-container">
        <pre><code class="language-dart">
  // domain/entities/werewolf_room.dart
  @freezed
  class WerewolfRoom with _$WerewolfRoom {
    const factory WerewolfRoom({
      required String id,
      required String roomCode,
      required List<WerewolfPlayer> players,
      required GamePhase phase,
      required Map<String, WerewolfRole> roles,
      @Default(<String, String>{}) Map<String, String> votes,
      @Default(100.0) double targetPoints,
      DateTime? gameStartTime,
      String? winningSide,
    }) = _WerewolfRoom;

    factory WerewolfRoom.fromJson(Map<String, dynamic> json) =>
        _$WerewolfRoomFromJson(json);
  }
        </code></pre>
      </div>

      <h5>4. Infrastructure層（インフラストラクチャ層）</h5>
      <div class="center-container">
        <pre><code class="language-dart">
  // infrastructure/werewolf_repository.dart
  class WerewolfRepository {
    final SupabaseClient _supabaseClient;
    static const String _roomsTable = 'werewolf_rooms';

    /// ルームデータをSupabaseに保存
    Future<void> saveRoom(WerewolfRoom room) async {
      await _supabaseClient.from(_roomsTable).upsert({
        'id': room.id,
        'host_id': _getCurrentUserId(),
        'data': room.toJson(),
        'updated_at': DateTime.now().toIso8601String(),
      });
    }

    /// リアルタイム同期用ストリーム
    Stream<WerewolfRoom> listenToRoom(String roomId) {
      return _supabaseClient
          .from(_roomsTable)
          .stream(primaryKey: ['id'])
          .eq('id', roomId)
          .map((data) => WerewolfRoom.fromJson(data.first['data']));
    }
  }
        </code></pre>
      </div>
      <h4>werewolfアーキテクチャの特徴</h4>
      <ul>
        <li><strong>完全なレイヤー分離</strong>：各層が明確に分離され、依存関係が一方向</li>
        <li><strong>Freezedによる型安全性</strong>：全エンティティがイミュータブルで型安全</li>
        <li><strong>リアルタイム対応</strong>：SupabaseのStreaming APIを活用したリアルタイム同期</li>
        <li><strong>テスタビリティ</strong>：各層が独立してテスト可能な設計</li>
        <li><strong>スケーラビリティ</strong>：新機能追加時の影響範囲を最小限に抑制</li>
      </ul>
      <p>この構造により、複雑なリアルタイムゲームロジックを保守性高く実装でき、将来的な機能拡張にも柔軟に対応可能なアーキテクチャが確保されています。</p>
    </main>
    <aside>
      <nav>
        <strong>目次</strong>
        <ul>
          <li><a href="#section1">全体構造</a></li>
          <li><a href="#section2">libディレクトリ</a></li>
          <li><a href="#section3">werewolfディレクトリ</a></li>
        </ul>
      </nav>
    </aside>
  </div>
</body>
</html>