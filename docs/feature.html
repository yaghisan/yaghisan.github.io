<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="../assets/portfolio.css">
  <script src="../submenu.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/prismjs/themes/prism-tomorrow.css" rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs/components/prism-dart.min.js"></script>

  <title>主要機能</title>
</head>
<body>
  <header class="progress-bar">
    <h3>portfolio/feature</h3>
    <div class="center-container">
      <div class="beige-background">
        <div class="upper-nav">
          <a href="../index.html">Home</a>
          <div class="portfolio-dropdown">
            <a href="#" id="portfolio-link" onclick="togglePortfolioFixed(event)">Portfolio</a>
            <div id="portfolio-submenu" class="portfolio-submenu">
              <a href="tech.html">技術スタック</a>
              <a href="architecture.html">アプリケーション構造</a>
              <a href="feature.html">主要機能</a>
              <a href="overview.html">今後の展望</a>
            </div>
          </div>
          <a href="profile.html">Profile</a>
        </div>
      </div>
    </div>
  </header>
  <div class="abstract">
    <h3>🎍</h3>
    <h1>主要機能</h1>
    <h2>主要機能まとめ (2025/6 現在)</h2>
  </div>
  <div class="container">
    <main>
      <h2>主要機能</h2>
      <h3>A. ユーザー登録/ログイン機能</h3>
      <p>unreal.appでは、Supabase AuthとFirebase Authを組み合わせたセキュアな認証システムを提供しています。</p>
      <div class="row-images">
        <img src="../assets/images/signup.png" alt="サインアップ画面" class="mobile-image">
        <img src="../assets/images/login.png" alt="ログイン画面" class="mobile-image">
      </div>
      <div class="center-container">
        <button class="toggle-btn" onclick="toggleDetails()">▼ 詳細を表示</button>
      </div>
      <div id="details" class="collapsed">
        <div class="grey-background">
          <h4>ユーザー登録フロー</h4>
          <div class="center-container">
          <pre><code class="language-dart">
  /// ユーザー登録処理
  Future<void> signUp({
    required String email,
    required String password,
    String? username,
  }) async {
    try {
      state = state.copyWith(isLoading: true, error: null);

      final AuthResponse response = await _client.auth.signUp(
        email: email,
        password: password,
        data: <String, dynamic>{
          if (username != null) 'name': username,
          'username': username ?? 'ユーザー',
        },
      );

      if (response.user != null) {
        // ユーザープロフィールをusersテーブルに保存
        await _client.from('users').insert(<String, dynamic>{
          'id': response.user!.id,
          'email': email,
          'name': username ?? 'ユーザー',
          'created_at': DateTime.now().toIso8601String(),
        });

        state = state.copyWith(user: response.user, isLoading: false);
      }
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: _translateError(e.toString()),
      );
    }
  }
          </code></pre>
        </div>
      <h4>ログインフロー</h4>
      <div class="center-container">
        <pre><code class="language-dart">
  /// ログイン処理
  Future<void> signIn({required String email, required String password}) async {
    try {
      state = state.copyWith(isLoading: true, error: null);

      final AuthResponse response = await _client.auth.signInWithPassword(
        email: email,
        password: password,
      );

      if (response.user != null) {
        state = state.copyWith(user: response.user, isLoading: false);
        // ログイン成功時はロビーに自動遷移
      }
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: _translateError(e.toString()),
      );
    }
  }
        </code></pre>
      </div>
        </div>
      </div>
      <p>認証システムでは、リアルタイムでの認証状態監視、日本語エラーメッセージ対応、メール確認リンクの再送信機能を提供し、ユーザビリティを重視した設計になっています。</p><hr>
      <h3>B. ワンナイト人狼について</h3>
      <p>ワンナイト人狼は、本アプリのメイン機能として実装されたリアルタイムマルチプレイヤーゲームです。</p>
      <h4>1.0 ゲーム作成</h4>
      <p>ゲーム作成では、汎用的なGameRoomとワンナイト人狼専用のWerewolfRoomを同時に作成し、統合的に管理します。</p>
      <div class="row-images">
        <img src="../assets/images/chosa.png" alt="ゲーム作成画面" class="mobile-image">
        <img src="../assets/images/ONwolf/join.png" alt="ゲーム作成画面" class="mobile-image">
      </div>
      <div class="grey-background">
        <h5>裏側の処理</h5>
        <div class="center-container">
          <pre><code class="language-dart">
    // 1. 汎用のGameRoomを作成（ルーム参加で検索できるように）
    final GameRoom gameRoom = await roomService.createRoom(
      name: roomName,
      gameType: 'werewolf',
      hostId: currentUser.id,
      description: 'ワンナイト人狼のルーム',
      isPrivate: false,
    );

    // 2. ワンナイト人狼専用のルームを作成（ゲーム進行用）
    final WerewolfRoom werewolfRoom = await gameService.createRoom(
      hostId: currentUser.id,
      hostName: userName,
      roomName: roomName,
      roomId: gameRoom.id, // 同じIDを使用して統合
    );
          </code></pre>
        </div>
      </div>
      <p>この二重構造により、ルーム検索機能とゲーム進行ロジックを分離し、スケーラビリティを確保しています。作成されたルームには6桁のユニークなルームコードが自動生成され、他のプレイヤーが参加できるようになります。</p>
      <h4>1.1 ゲーム参加</h4>
      <p>プレイヤーは6桁のルームコードを入力することで、既存のゲームルームに参加できます。</p>
      <h5>裏側の処理</h5>
      <div class="center-container">
        <pre><code class="language-dart">
    // ルームコードでルームに参加
    final GameRoom? room = await roomService.joinRoomByCode(
      roomCode: codeController.text,
      playerId: currentUser.id,
    );

    // ワンナイト人狼の場合は、WerewolfRoomにもプレイヤーを追加
    if (gameType == 'werewolf') {
      final werewolfRoom = await werewolfRepository.getRoom(room.id);
      if (werewolfRoom != null) {
        await werewolfService.addPlayer(
          werewolfRoom,
          id: currentUser.id,
          name: userName,
          isBot: false,
        );
      }
    }
        </code></pre>
      </div>
      <p>参加処理では、まずGameRoomレベルでの参加確認を行い、その後ワンナイト人狼専用のWerewolfRoomにプレイヤー情報を同期します。エラーハンドリングにより、片方の処理が失敗したとしても、もう片方は継続されます。</p>
      <h4>2.0 ゲーム開始</h4>
      <p>ホストプレイヤーがゲーム開始ボタンを押すと、役職配布と夜フェーズへの移行が自動で実行されます。</p>
      <h5>裏側の処理</h5>
      <div class="center-container">
        <pre><code class="language-dart">
    Future<WerewolfRoom> startGame(WerewolfRoom room) async {
      if (room.players.length < 3) {
        throw Exception('ゲームを開始するには最低3人のプレイヤーが必要です');
      }

      // 役職の設定
      final WerewolfRoom setupRoom = _setupRoles(room);

      // 夜フェーズに移行
      final WerewolfRoom nightRoom = setupRoom.copyWith(
        phase: GamePhase.night,
        gameStartTime: DateTime.now(),
      );

      // ボットの夜の行動を処理
      final WerewolfRoom withBotActions = _botActions.processBotNightActions(nightRoom);

      await _repository.saveRoom(withBotActions);
      return withBotActions;
    }
        </code></pre>
      </div>
      <p>ゲーム開始時に、基本役職（村人×2、人狼×2、占い師×1、怪盗×1）がランダムに配布され、プレイヤー数分の役職と中央カード用の役職が決定されます。同時にボットプレイヤーの夜の行動も自動処理されます。</p>
      <h4>3.0 夜のターン</h4>
      <p>夜フェーズでは、各役職が秘密裏に行動を実行します。占い師は他プレイヤーまたは墓地のカードを占い、怪盗は他プレイヤーと役職交換を行います。</p>
      <div class="row-images">
        <img src="../assets/images/ONwolf/night1.png" alt="夜フェーズでの役職行動画面" class="mobile-image">
        <img src="../assets/images/ONwolf/night2.png" alt="夜フェーズでの役職行動画面" class="mobile-image">
      </div>
      <h5>裏側の処理</h5>
      <div class="center-container">
        <pre><code class="language-dart">
    // 夜フェイズの終了確認
    bool isNightPhaseComplete(WerewolfRoom room) {
      final List<WerewolfRole> actionRequiredRoles = [
        WerewolfRole.seer,
        WerewolfRole.thief,
        WerewolfRole.werewolf,
      ];

      final List<WerewolfPlayer> actionRequiredPlayers =
          room.players.where((player) {
            final role = room.currentRoles[player.id];
            return role != null && actionRequiredRoles.contains(role);
          }).toList();

      // 全ての行動必要プレイヤーが行動済みかチェック
      return actionRequiredPlayers.every(
        (player) => room.nightActions.containsKey(player.id),
      );
    }
        </code></pre>
      </div>
      <p>夜の行動は nightActionsマップで管理され、行動が必要な全役職（占い師、怪盗、人狼）の行動完了を監視しています。ボットプレイヤーは自動的にランダムな行動を実行するため、すべての人間プレイヤーの行動終了が実質的なフラグになっています。</p>
      <h4>4.0 昼のターン</h4>
      <p>昼フェーズ（議論時間）は5分間に設定されています。しかし、時間内にすべてのプレイヤーが投票ボタンを押すことで即座に投票フェーズと移ることができます。</p>
      <h4>4.1 投票のターン</h4>
      <p>議論時間終了後、各プレイヤーは処刑したい相手に投票します。自分自身には投票できません。</p>
      <h4>4.2 結果発表</h4>
      <p>全員の投票完了後、勝利陣営の判定とポイント計算が自動実行されます。</p>
      <div class="row-images">
        <img src="../assets/images/ONwolf/vote.png" alt="投票画面" class="mobile-image">
        <img src="../assets/images/ONwolf/select.png" alt="結果発表画面" class="mobile-image">
      </div>
      <h5>裏側の処理</h5>
      <div class="center-container">
        <pre><code class="language-dart">
    WerewolfRoom calculateGameResult(WerewolfRoom room) {
      // 投票の集計
      final Map<String, int> voteCounts = {};
      for (final vote in room.votes.values) {
        voteCounts[vote] = (voteCounts[vote] ?? 0) + 1;
      }

      // 最多得票者を特定
      String? executedPlayerId;
      int maxVotes = 0;
      voteCounts.forEach((playerId, count) {
        if (count > maxVotes) {
          maxVotes = count;
          executedPlayerId = playerId;
        }
      });

      // 勝利陣営の判定
      String winningSide = '村人陣営';
      if (executedPlayerRole == WerewolfRole.werewolf) {
        winningSide = '村人陣営';
      } else if (executedPlayerRole == WerewolfRole.tanner) {
        winningSide = '吊り人';
      } else {
        winningSide = hasWerewolf ? '人狼陣営' : '村人陣営';
      }

      // ポイント計算と結果フェーズに移行
      final gamePoints = _calculatePoints(room, executedPlayerId, winningSide);
      return room.copyWith(
        phase: GamePhase.result,
        winningSide: winningSide,
        currentGamePoints: gamePoints,
      );
    }
        </code></pre>
      </div>
      <p>投票集計では最多得票者が処刑され、その役職に応じて勝利陣営が決定されます。また、独自のポイントシステムにより勝利チームに2pt、加えて役職固有のボーナスポイントが付与されます。</p>
      <h4>5.0 ゲーム再開or中断</h4>
      <p>結果発表後、プレイヤーは「調査継続」（次ゲーム開始）または「調査中断」（最終結果へ）を選択できます。</p>
      <h4>5.1 最終結果画面</h4>
      <p>調査中断または誰かが目標ポイント（デフォルト20pt）に到達した場合、最終結果画面が表示されます。</p>
      <div class="center-container">
        <img src="../assets/images/ONwolf/final_result.png" alt="最終結果" class="fixed-image">
      </div>
      <h5>裏側の処理</h5>
      <div class="center-container">
        <pre><code class="language-dart">
    WerewolfRoom calculateFinalResults(WerewolfRoom room) {
      // プレイヤーのポイントを更新
      final updatedPlayers = room.players.map((player) {
        final gamePoints = room.currentGamePoints[player.id] ?? 0;

        // ポイント履歴を更新
        final updatedHistory = Map<String, double>.from(player.pointsHistory);
        final gameKey = 'game_${DateTime.now().millisecondsSinceEpoch}';
        updatedHistory[gameKey] = gamePoints;

        // 合計ポイントを更新
        final newTotalPoints = player.points + gamePoints;

        return player.copyWith(
          points: newTotalPoints,
          pointsHistory: updatedHistory,
        );
      }).toList();

      // 最終結果表示フェーズに移行
      return room.copyWith(
        phase: GamePhase.final_result,
        players: updatedPlayers,
      );
    }
        </code></pre>
      </div>
      <p>最終結果では、各プレイヤーの順位と累計獲得ポイントが表示されます。この画面から「ロビーに戻る」を選択することで、現在のルーム情報を保持したまま次のゲームをシームレスに開始することができます。</p>
    </main>
    <aside>
      <nav>
        <strong>目次</strong>
        <ul>
          <li><a href="#section1">ログイン機能</a></li>
          <li><a href="#section2">ワンナイト人狼</a></li>
        </ul>
      </nav>
    </aside>
  </div>
</body>
</html>